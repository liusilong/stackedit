


> Written with [StackEdit](https://stackedit.io/).

之前在类初始化时机的时候说道如下结论：

当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始话，但是这条规则并不适用与接口。
- 在初始化一个类时，并不会先初始化它所实现的接口
- 在初始化一个接口时，并不会先初始化它的父接口

因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的特定的静态变量时，才会导致接口的初始化。

我们通过下面两个例子说明以上结论：

```java
public class Demo5 {  
    public static void main(String[] args) {  
        System.out.println(MyChild5.a);  
    }  
}  
  
interface MyParent5 {  
    public static final int a = 4;  
}  
  
interface MyChild5 extends MyParent5 {  
    public static final int b = 5;  
}
```

我们加上 `+XX:+TraceClassLoading` 参数运行以上程序，部分输出如下：

```java
...
[Loaded sun.launcher.LauncherHelper from /usr/local/java/jdk1.8.0_171/jre/lib/rt.jar]
[Loaded sun.misc.URLClassPath$FileLoader$1 from /usr/local/java/jdk1.8.0_171/jre/lib/rt.jar]
[Loaded com.lsl.jvm.Demo5 from file:/home/liusilong/workspace/java/workspace/Jvm_Demo/out/production/Jvm_Demo/]
[Loaded sun.launcher.LauncherHelper$FXHelper from /usr/local/java/jdk1.8.0_171/jre/lib/rt.jar]
...

```



<!--stackedit_data:
eyJoaXN0b3J5IjpbLTExMDY1NTc5ODMsNzM4Mzc2MDUwLDczMD
k5ODExNl19
-->