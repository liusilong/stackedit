


> Written with [StackEdit](https://stackedit.io/).

之前在类初始化时机的时候说道如下结论：

当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始话，但是这条规则并不适用与接口。
- 在初始化一个类时，并不会先初始化它所实现的接口
- 在初始化一个接口时，并不会先初始化它的父接口

因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的特定的静态变量时，才会导致接口的初始化。

我们通过下面两个例子说明以上结论：

```java
public class Demo5 {  
    public static void main(String[] args) {  
        System.out.println(MyChild5.a);  
    }  
}  
  
interface MyParent5 {  
    public static final int a = 4;  
}  
  
interface MyChild5 extends MyParent5 {  
    public static final int b = 5;  
}
```

我们加上 `+XX:+TraceClassLoading` 参数运行以上程序，部分输出如下：

```java
...
[Loaded sun.launcher.LauncherHelper from /usr/local/java/jdk1.8.0_171/jre/lib/rt.jar]
[Loaded sun.misc.URLClassPath$FileLoader$1 from /usr/local/java/jdk1.8.0_171/jre/lib/rt.jar]
...
[Loaded com.lsl.jvm.Demo5 from file:/.../]
...
[Loaded sun.launcher.LauncherHelper$FXHelper from /usr/local/java/jdk1.8.0_171/jre/lib/rt.jar]
...
4
...
```

由此可见 `MyParent5` 和 `MyChild5` 两个接口并没有被加载，因为接口中的变量都是 `public static final` 的常量，在编译器就会放到调用该常量的方法所在类的常量池当中。

我们把上面的 MyChild5 有一个接口变成一个类，其他不变，如下：

```java
class MyChild5 implements MyParent5 {  
    public static final int b = 5;  
}
```

配置 `-XX:+TranceClassLoading` 参数，运行如下：





<!--stackedit_data:
eyJoaXN0b3J5IjpbNDQyMzU1OTczLDczODM3NjA1MCw3MzA5OT
gxMTZdfQ==
-->