


> Written with [StackEdit](https://stackedit.io/).

## 类的加载

来看看 `ClassLoader # loadClass(...)` 方法的注释

加载一个指定二进制名字(java.lang.String) 的类，这个方法的默认实现会按照如下顺序去寻找类：

1. 调用 `findLoadedClass(...)` 来检查这个类是否被加载过。
2. 调用父类的 `loadClass` 方法。如果父加载器为空，就会调用启动类加载器
3. 调用 `findClass(...)` 来寻找这个类

若有一个类加载器能够成功的加载 Test 类，那么这个来加载器被称为 **定义类加载器**，所有能成功返回 Class 对象引用的类加载器（包括定义类加载器）都被称为 **初始类加载器**

### 命名空间

- 每个类加载器都有自己的命名空间，命名空间由该**类加载器**及所有**父加载器所加载的类**组成
- 在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类
- 在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类

**在同一命名空间下，一个类只能被加载一次**
**在不同的命名空间下，两个完全相同的类可以被加载多次**

### 类加载器

根类加载器，扩展类加载器，系统/应用类加载器 以及用户自定义类加载器。它们之间虽然遵循双亲委托的加载机制，但是它们之间的关系并不是父子关系，而是包含关系。如下：

```java
MyClassLoader loader1 = new MyClassLoader("loader1");
MyClassLoader loader2 = new MyClassLoaser(loader1, "loader2");
```

上述代码中，loader1 和 loader2 都是 MyClassLoader 的实例对象，但是我们在实例化 loader2 的时候，显示的将 loader1 指定为 loader2 的父加载器。进而可以说明类加载器之间是包含的关系，而不是父子的关系。

## 类的卸载

当 MySample 类被加载、连接、初始化后，它的生命周期就开始了。当代表 MySamle 类的Class对象不再被引用，即不可触及时，Class 对象就会结束生命周期，MySample 类在方法区内的数据也会被卸载，从而结束 MySample 类的生命周期。

一个类何时结束生命周期，取决于代表它的 Class 对象何时结束生命周期。

**由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载**。前面已经介绍过，Java 虚拟机自带的类加载器包括根类加载器、扩展类加载器和系统类加载器。Java 虚拟机本身会始终引用这些类加载器，而这些来加载器则会始终引用它们所加载类的 Class 对象，因此这些 Class 对象始终是可触及的。

**由用户自定义的类加载器所加载的类是可以被卸载的。** 

验证类的卸载我们可以配置 `-XX:+TraceClassUnloading`  VM options , 然后手动调用 `System.gc()` 来看日志
<!--stackedit_data:
eyJoaXN0b3J5IjpbOTUwNTU2NzYxXX0=
-->