


> Written with [StackEdit](https://stackedit.io/).

# 34_类加载器内容回顾与内容延伸

### 概念
- 在Java代码中，类型的加载、连接与初始化过程都是在程序运行期间完成的
- 提供了更大的灵活性，增加了更多的可能性
- Java虚拟机与程序的声明周期
- 在如下的集中情况下，Java虚拟机将结束声明周期
    - 执行了 `System.exit()` 方法
    - 程序正常执行结束
    - 程序在执行过程中遇到了异常或错误而导致终止
    - 由于操作系统出现错误而导致Java虚拟机进程终止

    
### 类加载顺序
- 加载：查找并加载类的二进制数据
- 连接：
    - 验证：确保被加载的类的正确性
    - 准备：为类的**静态变量**分配内存，并将其初始化为**默认值**
    - 解析：把类中的符号引用转换为直接引用
- 初始化：为类的**静态变量**赋予正确的**初始值**

### Java对类的使用
- Java程序对类的使用方式可分为两种
    - 主动使用
    - 被动使用
- 所有的Java虚拟机实现必须在每个类或接口被Java程序 **首次主动使用** 时才**初始化**它们

#### 主动使用的情况
- 创建类的实例
- 访问某个类或接口的静态变量，或者对该静态变量赋值
- 调用类的静态方法
- 反射 如 `Class.forName("com.test.Test")`
- 初始化一个类的子类
- Java 虚拟机启动时被标记为启动类的类
- JDK1.7 开始提供动态语言支持：`java.lang.invoke.MethodHandle` 实例的解析结果 `REF_getStatic`, `REF_putStatic`, `REF_invokeStatic` 句柄对应的类没有初始化，则初始化。

除了以上七中情况，其他使用 Java 类的方式都被看作是对类的 **被动使用** ，都不会导致类的 **初始化**。

### 类加载
类的加载通常是将 `.class` 文件从磁盘加载到内存中。
类的加载的最终产物是位于内存中的 Class 对象
Class 对象封装了类在方法区内的数据结构，并且向 Java 程序员提供了访问方法区内的数据结构的接口

#### 加载 `.class` 文件的方式
- 从本地系统中直接加载
- 通过网络下载 `.class` 文件
- 从 zip, jar 等归档文件中加载 `.class` 文件
- 从专有的数据库中提取 `.class` 文件
- 将 Java 源文件动态编译为 `.class` 文件

#### 一个对象的生成流程

加载 --> 验证 --> 准备 --> 解析 --> 初始化 --> 类实例化 --> 垃圾回收和对象终结


**类实例化：**
- 为新的对象分配内存
- 为实例变量赋默认值
- 为实例变量赋正确的初始化

Java 编译器为它编译的每一个类都至少生成一个实例初始化的方法，在 Java 的 class 文件中，这个实例初始化方法被称为 `<init>` 。针对源代码中的每一个类的构造方法，Java 编译器都产生一个 `<init>` 方法。

### 类加载器
#### Java虚拟机自带的加载器
- 启动类加载器（Bootstrap ClassLoader）
- 扩展类加载器（Extension ClassLoader）
- 系统（应用）类加载器（App ClassLoader）

#### 用户自定义的类加载器
- java.lang.ClassLoader 的子类
- 用户可以定制类的加载方式

类加载器并不需要等到某个类被 首次主动使用 的时候再加载它。

JVM 规范允许类加载器在预料到某个类将要使用时就预先加载它，如果在预先加载的过程中遇到了 .class 文件缺失或存在错误，类加载器必须在 程序首次主动使用 该类是才报告错误（LinkageError 错误）

如果这个类一直没有被程序主动使用，那么 类加载器就不会报告错误

类被加载后，就进入连接阶段。连接就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。

在双亲委托机制中，各个加载器按照父子关系形成了树形结构，除了根类加载器之外，其余的类加载器都有且只有一个父加载器。

父加载器和子加载器之间的关系并非继承关系，可以理解为包含关系。

若有一个类成功的加载了 Test 类，那么这个类加载器被称为**定义类加载器**，所有能够成功返回 Class 对象引用的类加载器（包括定义类加载器）都被称为**初始类加载器**

#### 类验证的内容
- 类文件的结构检查
- 语意检查
- 字节码验证
- 二进制兼容性验证


### 类的初始化
静态变量声明的语句，以及静态代码块都被看作类的初始化语句，JVM 会按照初始化语句在类文件转给你的先后顺序来一次的执行它们。

#### 类初始化步骤
- 假如这个类还没有被加载和连接，那就先进行加载和连接
- 假如类存在直接父类并且这个父类还没有被初始化，那就先初始化直接父类
- 假如类中存在初始化语句，那就依次执行这些初始化语句

#### 类初始化时机
- 当Java虚拟机初始化一个类的时候，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口
- 在初始化一个类时，并不会先初始化它所实现的接口
- 在初始化一个接口时，并不会先初始化它的父接口

因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量（接口中的变量都是静态变量）时，才会导致该接口的初始化。

只有当程序访问的静态变量或静态方法确实在当前类或者当前接口中定义的时候，才可以人文是对类或者接口的主动使用。

调用 ClassLoader 类的 loadClass 方法加载一个类，并不是对类的主动使用，不会导致类的初始化。 

### 获得 ClassLoader 的途径
- 获得当前类的 ClassLoader
    - `class.getClassLoader()`
- 获得当前线程上下文的 ClassLoader
    - `Thread.currentThread().getContextClassLoader()`
- 获得系统的 ClassLoader
    - `ClassLoader.getSystemClassLoader()`

线程上下文类加载器可以让我们在运行期手动设置当前类的类加载器，而不需要遵循类加载器的双亲委托机制。

### 双亲委托的优点
双亲委托机制的有点是能够提高软件系统的安全性。因为在此机制下，用户自定义的类加载器不可能加载应该由父加载器加载的可靠类，从而防止不可靠甚至恶意代码代替由父加载器加载的可靠代码。例如，`java.lang.Object` 类总是由启动类加载器加载，其他任何用户自定义的类加载器都不可能加载含有恶意代码的 `java.lang.Object` 类。

### 命名空间
- 每个类加载器都有自己的命名空间。命名空间由该加载器及所有父加载器所加载的类组成
- 在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类
- 在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类

#### 不同类加载器的命名空间的关系
- 同一个命名空间内的类是相互可见的
- 子加载器的命名空间包含所有父加载器的命名空间。因此由子加载器加载的类能看见父加载器加载的类。例如系统类加载器加载的类能看见启动类加载器加载的类
- 由父加载器加载的类不能看见子加载器加载的类
- 如果两个加载器之间没有 直接或间接的父子关系，那么他们各自加载的类相互不可见

### 自定义类加载器
要创建用户自己的类加载器，只需要继承 `java.lang.ClassLoader` 类，然后覆盖它的 `findClass(String name)` 方法即可，该方法根据参数指定的名字，返回对应的 `Class` 对象的引用。

### 类的卸载
由虚拟机自带的类加载器加载的类是无法卸载的；而又用户自定义的类加载器所加载的类是可以被卸载的。

一个类何时结束生命周期，取决于代表他的 Class 对象何时结束生命周期
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTM5MTk3NTgzNl19
-->