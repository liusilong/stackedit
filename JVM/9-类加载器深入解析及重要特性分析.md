


> Written with [StackEdit](https://stackedit.io/).

### 类的加载顺序：

**加载**：就是把二进制形式的java类型读入java虚拟机中

**链接**:

 - 验证：验证加载进来的class文件的正确性
 - 准备：为类的静态变量分配内存，设置默认值。但是在到达初始化之前，类的静态变量都没有初始化为真正的初始值。
 - 解析：解析过程就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程

**初始化**：为类的静态变量赋予正确的初始值。

**类实例化**：
为新的对象分配内存
为实例变量赋默认值
为实例变量赋真正的初始值
java编译器为它编译的每一个类都至少生成一个实例初始化方法，在Java的class文件中，这个实例初始化方法被称为 `<init>` 。针对源代码中的每一个类的构造方法，java编译器都产生一个 `<init>` 方法。


#### 类的加载

类的加载的最终产品是位于内存中的`Class`对象

`Class`对象封装了类在方法区内的数据结构，并且向**Java**程序员提供了访问方法区内的数据结构的接口

由此可见Class对象是反射的入口

#### 类加载器
这里有两种类型的类加载器：**Java虚拟机自带的加载器**和**用户自定义的加载器**

- **Java虚拟机自带的加载器**
	- 根类加载器（Bootstrap)
	- 扩展类加载器（Extension）
	- 系统（应用）类加载器（System）
- **用户自定义的类加载器**
	- `java.lang.ClassLoader`的子类
	- 用户可以定制类的加载方式

类加载器并不需要等到某个类被 **首次主动使用** 时再加载它

**JVM**规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了`.class`文件缺失或存在错误，类加载器必须在**程序首次主动**使用该类时才报告错误（ `LinkageError` 错误）

如果这个类一直没有被程序主动使用，那么 **类加载器就不会报告错误**

#### 类的验证
类被加载后，就进入连接阶段。连接就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。

类验证的内容：
- 类文件的结构检查
- 语义检查
- 字节码验证
- 二进制兼容性的验证

##### 类的准备
在准备阶段，**Java**虚拟机为类的静态变量分配内存，并设置默认的初始值。例如对于一下`Sample`类，在准备阶段，将为`int`类型的静态变量`a`分配**4**个字节的内存空间，并且赋予默认值`0`，为`long`类型的静态变量`b`分配**8**个字节的内存空间，并且赋予默认值0。

```java
class Sample {
	private static int a = 1;
	private static long b;
	static{
		b = 2;
	}
}
```

### 类的初始化
在初始化阶段，Java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。在程序中，静态变量的初始化有两种途径：
1. 在静态变量声名出进行初始化
2. 在静态代码块中进行初始化

例如在一下代码中，静态变量a和b都被显示初始化，而静态变量c没有被显示初始化，它将保持默认值0;。

```java
class Sample {
	// 在静态变量的声明处进行初始化
	private static int a = 1;
	private static long b;
	private static long c;
	
	static{
		// 在静态代码块中进行初始化
		b = 2;
	}
}
```

**静态变量的声明语句，以及静态代码块都被看做类的初始化语句**，Java虚拟机会按照初始化语句在类文件中的先后顺序来依次执行他们。例如当一下Sample类被初始化后，它的静态变量a的取值为4.

```java
class Sample{
	static int a = 1;
	static { a = 2; }
	static { a = 4; }
	public static void main(String[] args){
		System.out.println("a = " + a); // a = 4
	}
}
```

##### 类的初始化步骤
- 假如这个类还没有被加载和连接，那么就先进行加载和连接
- 假如类存在直接父类，并且这个父类还没有被初始化，那么就先初始化直接父类
- 假如类中存在初始化语句，那就依次执行这些初始化语句

##### 类初始化时机
当Java虚拟机初始化一个类的时候，要求他的所有父类都已经被初始化，但是这条规则并不适用于接口:
- 在初始化一个类时，并不会先初始化它所实现的接口。
- 在初始化一个接口时，并不会先初始化它的父接口。

因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量时，才会导致接口的初始化。

只有当程序访问的静态变量或者静态方法确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使用。

调用 `ClassLoader` 类的 `loadClass` 方法加载一个类，并不是对类的主动使用，不会导致类的初始化。

类加载器用来把类加载到Java虚拟机中。从 JDK 1.2 版本开始，类的加载过程采用父亲委托机制，这种机制能更好地保证Java平台的安全。在此委托机制中，除了Java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父类加载器。

当Java
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE2NDgzMTQ2MDMsMTM3MzU1NjA2NCwyMD
cyNjkxNTk3LDE1OTU4MDczODAsMTQ4MTM4NjQyXX0=
-->