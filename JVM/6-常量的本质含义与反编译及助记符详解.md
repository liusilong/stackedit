


> Written with [StackEdit](https://stackedit.io/).


### 类的加载顺序
**对于一个静态字段来说，只有直接定义了该字段的类才会被初始化；**
当一个类在初始化时，要求其父类全部都已经初始化完毕。

`-XX:+TraceClassLoading` 用于追踪类的加载信息并打印出来

下面我们来看一个例子来验证上面的结论：
```java
public class Demo1 {  
    public static void main(String[] args) {  
        System.out.println(MyChild1.str);  
    }  
}  
  
class MyParent1 {  
    public static String str = "hello world";  
  
    static {  
        System.out.println("MyParent1 static block");  
    }  
}  
  
class MyChild1 extends MyParent1 {  
    public static String str2 = "welcome";  
  
    static {  
        System.out.println("MyChild1 static block");  
    }  
}
```

上面的程序输出如下：

```java
MyParent1 static block
hello world
```

也就是说上面的 `MyChild1` 没有被初始化，否则，`MyChild1` 中静态代码块中的内容会被输出。

**但是 `MyChild1` 有没有被加载呢？**

我们在运行上述程序的时候加入 `-XX:+TraceClassLoading` 参数配置（Edit Configurations --> VM options）再次运行看看输出。此处输出会很多，会将所有类的加载信息都打印出来，部分如下：

```java
[Loaded java.lang.Object from /usr/local/java/jdk1.8.0_171/jre/lib/rt.jar]
...
[Loaded com.lsl.jvm.Demo1 from file:/...]
...
[Loaded com.lsl.jvm.MyParent1 from file:/...]
[Loaded com.lsl.jvm.MyChild1 from file:/...]
MyParent1 static block
hello world
```

从上述输出可以看出，加载顺序为 `MyDemo1` --> `MyParent1` --> `MyChild1`

因为 MyDemo1 类里面包含main方法，会被标记为程序的启动类（会触发类的主动使用），所以会最先被加
载。

然后就是 加载并初始化了 `MyParent1`。

**`MyChild1` 也会被虚拟机加载，但是没有初始化。**

### JVM参数选项

`-XX:+<option>` : 表示开启 option 选项， 如： `-XX:+TraceClassLoading`
`-XX:-<option>` : 表示关闭 option 选项
`-XX:<option>=<value>` : 表示将 option 选项的值设置为 value

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTMxNTUyMjM0MCwxMDc1MTE1ODU5XX0=
-->