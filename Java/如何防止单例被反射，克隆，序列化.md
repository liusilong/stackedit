


> Written with [StackEdit](https://stackedit.io/).

## 如何防止单例被反射，克隆，序列化
[原文链接](https://www.geeksforgeeks.org/prevent-singleton-pattern-reflection-serialization-cloning/)

这本文中，我们想看到如何破坏单利模式以及如何避免的方法。这里主要有3个概念打破一个类的单例属性，我们一个一个的往下看：

### 反射
反射可以破坏一个类的单利的属性，如下：

```java
public class BrokenSingleton {  
    public static void main(String[] args) throws Exception{  
        Singleton instance1 = Singleton.instance;  
        Singleton instance2 = null;  
        Constructor<?>[] constructors = Singleton.class.getDeclaredConstructors();  
        for (Constructor<?> constructor : constructors) {  
            constructor.setAccessible(true);  
            // 使用反射生成 Singleton 类的实例
            instance2 = (Singleton) constructor.newInstance();  
            break;  
        }  
  
        System.out.println("instance1.hashCode(): " + instance1.hashCode());  
        System.out.println("instance2.hashCode(): " + instance2.hashCode());  
    }  
}  
 
// 单例类
class Singleton {  
    public static Singleton instance = new Singleton();  
    private Singleton(){  
  
    }  
}
```
输出：
```java
instance1.hashCode(): 1735600054
instance2.hashCode(): 21685669
```

很明显可以看出 `instance1` 和 `instance2` 的 `hashCode` 是不一样的，也就是说它们两个是 `Singleton` 类的不同的实例。

解决办法：
使用枚举 `Enum` 类来实现单例。因为在枚举类内部`Java`保证枚举值只会初始化一次。由于 Java 中的枚举是可以全局访问的，所以枚举可以作为单例类。它唯一的缺点就是不灵活，因为它不能延迟初始化。

```java
public enum Singleton{  
    INSTANCE  
}
```

由于枚举没有任何构造函数，因此无法使用反射来实例化它。
<!--stackedit_data:
eyJoaXN0b3J5IjpbOTQ3NDc4NzEwLC0xMzQzODE0MTk1LC0xMT
E0MDcxNDc5XX0=
-->